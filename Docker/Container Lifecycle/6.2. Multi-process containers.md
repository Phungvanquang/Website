# 6.2. Multi-process containers

#### **1. Nguyên lý & Triết lý Docker**

* **Triết lý gốc** của Docker: **1 container = 1 process chính** → dễ scale, monitor, restart.
* Lý do:

  * PID 1 của container chính là process chính.
  * Khi process chính kết thúc, container sẽ dừng.
  * Docker quản lý signal, logging, và restart policies dựa trên process này.
#### **2. Khi nào cần Multi-process**

Dù khuyến nghị "single-process", thực tế có những **trường hợp bắt buộc**:

1. **Ứng dụng nguyên khối (monolithic)**: Không dễ tách ra service riêng.
2. **Service phụ trợ bắt buộc chạy chung**:

   * Nginx proxy + PHP-FPM
   * Cronjob + main app
   * SSH daemon + dev environment
3. **Dev / CI/CD environment all-in-one**:

   * Tránh setup nhiều container khi cần test nhanh.
4. **Tool đặc thù**:

   * Một số phần mềm cũ cần process watcher tích hợp.

#### **3. Vấn đề & Rủi ro**

* **Khó scale**: Không thể scale từng thành phần độc lập.
* **Crash toàn bộ**: Một process chết → container dừng (trừ khi supervisor restart nó).
* **Phức tạp về logging**: Phải gom log của nhiều process về stdout/stderr.
* **Quản lý signal khó**:

  * PID 1 không forward signal chuẩn → `docker stop` không dừng tất cả process.
  * Zombie process nếu không có init system dọn dẹp.
* **Tăng attack surface**: Nhiều service → nhiều lỗ hổng tiềm năng.

#### **4. Cơ chế chạy nhiều process**

##### **4.1. Init process / Supervisor**

Giải pháp là thêm một **process quản lý** (supervisor) làm PID 1:

* **Chức năng**:

  * Chạy nhiều process con.
  * Restart nếu crash.
  * Forward signal (SIGTERM, SIGINT).
  * Thu dọn zombie process.

###### **4.1.1. supervisord**

* **Ưu**: Phổ biến, dễ cấu hình, mạnh mẽ.
* **Nhược**: Image lớn hơn, config verbose.
* **Ví dụ**:

**Dockerfile**

```dockerfile
FROM ubuntu:22.04
RUN apt-get update && apt-get install -y supervisor nginx php-fpm
COPY supervisord.conf /etc/supervisor/conf.d/supervisord.conf
CMD ["/usr/bin/supervisord", "-n", "-c", "/etc/supervisor/supervisord.conf"]
```

**supervisord.conf**

```ini
[supervisord]
nodaemon=true

[program:nginx]
command=/usr/sbin/nginx -g "daemon off;"
autostart=true
autorestart=true

[program:php-fpm]
command=/usr/sbin/php-fpm -F
autostart=true
autorestart=true
```
###### **4.1.2. s6-overlay**

* **Ưu**: Nhẹ, thiết kế riêng cho container, xử lý signal tốt.
* **Nhược**: Học curve cao hơn.
* **Cách dùng**:

  * Copy `s6-overlay` vào container.
  * Tạo script `/etc/services.d/<service>/run` cho từng process.
* **Ví dụ cấu trúc**:

```
/etc/services.d/nginx/run
/etc/services.d/php-fpm/run
```
###### **4.1.3. runit**

* **Ưu**: Siêu nhẹ (\~40KB), init nhanh.
* **Nhược**: Ít tài liệu hơn.
* **Ví dụ**:

```dockerfile
FROM alpine:3.18
RUN apk add --no-cache runit nginx php-fpm
COPY service/ /etc/service
CMD ["runsvdir", "/etc/service"]
```
##### **4.2. Script entrypoint**

* Cách đơn giản: Tự viết shell script start nhiều process.
* **Ví dụ**:

```bash
#!/bin/sh
nginx &
php-fpm &
wait -n
exit $?
```

* **Nhược điểm**:

  * Không restart process khi chết.
  * Signal handling kém.
  * Không cleanup zombie.

#### **5. Case Study**

##### **Case 1: Dev environment all-in-one**

* **Mục tiêu**: Dùng 1 container cho full LEMP stack (Linux, Nginx, MySQL, PHP).
* **Giải pháp**: `supervisord` chạy 3 service.
* **Kết quả**: Tiện cho dev, nhưng production tách thành 3 container riêng.

##### **Case 2: Cronjob + main process**

* **Mục tiêu**: Ứng dụng cần chạy cron trong cùng môi trường.
* **Giải pháp**: `s6-overlay` để tách cron service & app service, cả 2 được giám sát.

#### **6. Best Practices**

1. **Chỉ dùng multi-process khi thật sự cần**.
2. **Ưu tiên supervisor nhẹ** (`s6`, `runit`) trong môi trường production.
3. **Luôn log ra stdout/stderr** → dễ dàng `docker logs`.
4. **Forward signal chuẩn** để tránh zombie process.
5. **Tách dev/POC và production**: Prod nên theo microservices.
6. **Healthcheck từng process** nếu critical.


